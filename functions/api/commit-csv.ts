import { corsHeaders, enforceRateLimit, errJSON, okJSON, requireAuth } from "../_utils";

// Cloudflare Pages Functions 型
type PagesFunction = (context: {
  request: Request;
  env?: Record<string, any>;
  [key: string]: any;
}) => Promise<Response> | Response;

async function githubFetch(path: string, token: string, init: RequestInit = {}): Promise<Response> {
  const url = `https://api.github.com${path}`;
  const headers = {
    authorization: `Bearer ${token}`,
    accept: "application/vnd.github+json",
    "content-type": "application/json; charset=utf-8",
    "user-agent": "Akyodex-Worker/1.0",
    "x-github-api-version": "2022-11-28",
    ...(init.headers as Record<string, string> | undefined),
  } as Record<string, string>;
  return fetch(url, { ...init, headers });
}

function extractAvtrFromUrl(url: string): string | null {
  if (!url) return null;
  const match = String(url).match(/avtr_[A-Za-z0-9-]+/);
  return match ? match[0].toLowerCase() : null;
}

function extractAvatarUrls(csvText: string): Map<string, string> {
  // CSVからID→アバターURLのマップを抽出
  const lines = csvText.split(/\r?\n/);
  const avatarUrls = new Map<string, string>();

  for (const line of lines) {
    if (!line.trim() || /^\s*ID\s*,/i.test(line)) continue;
    const fields = line.split(',');
    if (fields.length < 2) continue;

    const id = fields[0]?.trim();
    if (!id || !/^\d{3}$/.test(id)) continue;

    // アバターURLは最後のフィールド
    const url = fields[fields.length - 1]?.trim();
    const avtr = extractAvtrFromUrl(url);
    if (avtr) {
      avatarUrls.set(id, avtr);
    }
  }

  return avatarUrls;
}

async function updateAvatarMapIfNeeded(
  newCsvText: string,
  oldCsvText: string,
  owner: string,
  repo: string,
  branch: string,
  token: string
): Promise<boolean> {
  // アバターURLに変更があるか確認
  const oldUrls = extractAvatarUrls(oldCsvText);
  const newUrls = extractAvatarUrls(newCsvText);

  let hasChanges = false;

  // 新規追加または変更をチェック
  for (const [id, avtr] of newUrls) {
    if (!oldUrls.has(id) || oldUrls.get(id) !== avtr) {
      hasChanges = true;
      break;
    }
  }

  // 削除をチェック
  if (!hasChanges) {
    for (const id of oldUrls.keys()) {
      if (!newUrls.has(id)) {
        hasChanges = true;
        break;
      }
    }
  }

  if (!hasChanges) {
    return false; // 変更なし
  }

  // アバターマップを生成
  const sorted = Array.from(newUrls.entries()).sort((a, b) => {
    if (a[1] === b[1]) return a[0].localeCompare(b[0]);
    return Number(a[0]) - Number(b[0]);
  });

  const mapObject: Record<string, string> = {};
  for (const [id, avtr] of sorted) {
    mapObject[avtr] = id;
  }

  const mapContent =
    `// Auto-generated by tools/generate-avatar-map.mjs\n` +
    `// Do not edit manually.\n` +
    `export const AVATAR_ID_BY_AVTR = ${JSON.stringify(mapObject, null, 2)};\n` +
    `export default AVATAR_ID_BY_AVTR;\n`;

  // 現在のマップファイルを取得
  const mapPath = 'data/akyo-avatar-map.js';
  const getRes = await githubFetch(
    `/repos/${owner}/${repo}/contents/${encodeURIComponent(mapPath)}?ref=${encodeURIComponent(branch)}`,
    token
  );

  let mapSha: string | undefined;
  if (getRes.ok) {
    const json = await getRes.json();
    mapSha = json?.sha;
  }

  // マップをコミット
  const base64MapContent = btoa(unescape(encodeURIComponent(mapContent)));
  const mapPutRes = await githubFetch(
    `/repos/${owner}/${repo}/contents/${encodeURIComponent(mapPath)}`,
    token,
    {
      method: 'PUT',
      body: JSON.stringify({
        message: `chore: update avatar map (auto-generated from CSV)`,
        content: base64MapContent,
        branch,
        ...(mapSha ? { sha: mapSha } : {}),
      }),
    }
  );

  if (!mapPutRes.ok) {
    throw new Error(`Failed to update avatar map: ${mapPutRes.status} ${await mapPutRes.text()}`);
  }

  return true;
}

export const onRequestOptions: PagesFunction = async ({ request }) => {
  return new Response(null, { headers: corsHeaders(request.headers.get("origin") ?? undefined) });
};

export const onRequestPost: PagesFunction = async ({ request, env }) => {
  const origin = request.headers.get("origin") ?? undefined;
  try {
    // 認証とレート制限
    const role = requireAuth(request, env as any);
    await enforceRateLimit(request, env as any, {
      prefix: `commit-csv:${role}`,
      limit: role === "owner" ? 30 : 10,
      windowSeconds: 60,
    });

    const token = (env as any).GITHUB_TOKEN as string;
    const owner = ((env as any).GITHUB_REPO_OWNER as string) || ((env as any).REPO_OWNER as string);
    const repo = ((env as any).GITHUB_REPO_NAME as string) || ((env as any).REPO_NAME as string);
    const branch = ((env as any).GITHUB_BRANCH as string) || "main";
    if (!token || !owner || !repo) {
      return errJSON(500, "GitHub settings missing");
    }

    // CSV本文
    const csvText = await request.text();
    if (!csvText || csvText.length < 5) {
      return errJSON(400, "csv body required");
    }

    const path = `data/akyo-data.csv`;

    // 現行CSVの取得（shaと本文）
    async function getCurrentBase(): Promise<{ sha?: string; text: string; eol: "\n" | "\r\n" }> {
      const res = await githubFetch(`/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}`, token);
      if (!res.ok) return { sha: undefined, text: "", eol: "\n" };
      const json = await res.json();
      const sha = json?.sha as string | undefined;
      let text = "";
      try {
        const raw = json?.content ? String(json.content).replace(/\n/g, "") : "";
        text = decodeURIComponent(escape(atob(raw)));
      } catch (_) {
        text = "";
      }
      const eol = text.includes("\r\n") ? "\r\n" : "\n";
      return { sha, text, eol };
    }

    // 旧→新の最小差分で組み立て
    // 引用符内の改行を保持したまま、レコード単位で分割
    function splitCsvRecordsPreserveQuotes(text: string): string[] {
      if (!text) return [];
      const records: string[] = [];
      let cur = "";
      let inQuotes = false;
      const s = text.replace(/\r\n/g, "\n");
      for (let i = 0; i < s.length; i++) {
        const ch = s[i];
        cur += ch;
        if (ch === '"') {
          const next = s[i + 1];
          if (inQuotes && next === '"') { // エスケープ "" はそのまま消費
            cur += next;
            i++;
            continue;
          }
          inQuotes = !inQuotes;
        }
        if (!inQuotes && ch === '\n') {
          // レコード終端（引用外の改行）
          // 行末の\nは残しつつ、recordsには改行を含まない文字列として格納
          records.push(cur.endsWith("\n") ? cur.slice(0, -1) : cur);
          cur = "";
        }
      }
      if (cur.length) records.push(cur);
      return records;
    }

    function isHeader(line: string): boolean {
      return /^\s*ID\s*,/i.test(line) || /^\s*,?\s*見た目,/.test(line);
    }

    function parseFirstField(line: string): string | null {
      if (!line) return null;
      let i = 0; const n = line.length;
      // handle optional BOM
      if (line.charCodeAt(0) === 0xFEFF) i = 1;
      if (i >= n) return null;
      if (line[i] === '"') {
        i++; let field = "";
        while (i < n) {
          const ch = line[i];
          if (ch === '"') {
            if (i + 1 < n && line[i + 1] === '"') { field += '"'; i += 2; continue; }
            // end quote
            i++;
            // next should be comma or end
            return field;
          } else { field += ch; i++; }
        }
        return field || null;
      } else {
        const j = line.indexOf(',');
        return (j >= 0 ? line.slice(0, j) : line).trim() || null;
      }
    }

    function parseCsvLineToFields(line: string): string[] {
      // レコード全体（改行を含む場合あり）から値配列へ
      const fields: string[] = [];
      if (!line) return fields;
      if (line.charCodeAt(0) === 0xFEFF) line = line.slice(1);
      let i = 0;
      const n = line.length;
      while (i < n) {
        let field = "";
        let inQ = false;
        if (line[i] === '"') { inQ = true; i++; }
        while (i < n) {
          const ch = line[i];
          if (ch === '"') {
            const next = line[i + 1];
            if (inQ && next === '"') { field += '"'; i += 2; continue; }
            if (inQ) { i++; inQ = false; continue; }
          }
          if (!inQ && ch === ',') { i++; break; }
          field += ch; i++;
        }
        fields.push(field);
        // カンマが無く終了した場合は次ループでbreakされる
      }
      return fields;
    }

    function parseCsvToRows(text: string): { header?: string; rows: Array<{ id: string; raw: string; fields: string[] }> } {
      const records = splitCsvRecordsPreserveQuotes(text);
      const out: Array<{ id: string; raw: string; fields: string[] }> = [];
      let header: string | undefined;
      for (let idx = 0; idx < records.length; idx++) {
        const rec = records[idx];
        if (rec == null || rec === "") continue;
        if (!header && isHeader(rec)) { header = rec; continue; }
        const id = (parseFirstField(rec) || '').trim();
        if (!id || !/^\d{3}$/.test(id)) continue;
        const fields = parseCsvLineToFields(rec);
        out.push({ id, raw: rec, fields });
      }
      return { header, rows: out };
    }

    function parseCsvToMap(text: string): Map<string, { raw: string; fields: string[] }> {
      const { rows } = parseCsvToRows(text);
      const m = new Map<string, { raw: string; fields: string[] }>();
      rows.forEach(r => m.set(r.id, { raw: r.raw, fields: r.fields }));
      return m;
    }

    // 新CSVのID→行データ（レコード単位）
    const newMapOriginal = parseCsvToMap(csvText);

    function arraysEqual(a: string[], b: string[]): boolean {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }

    // 競合時リトライ
    let attempt = 0;
    const maxAttempts = 3;
    let lastErrorText = "";
    while (attempt < maxAttempts) {
      attempt++;
      // 最新のベースを毎回取得
      const { sha: currentSha, text: currentBaseText, eol } = await getCurrentBase();
      const baseParsed = parseCsvToRows(currentBaseText);

      // headerは既存優先→新CSVの先頭レコードがヘッダならそれ→デフォルト
      let header = baseParsed.header;
      if (!header) {
        const firstRec = splitCsvRecordsPreserveQuotes(csvText).find(l => !!l);
        if (firstRec && isHeader(firstRec)) header = firstRec;
      }
      if (!header) header = 'ID,見た目,通称,アバター名,属性（モチーフが基準）,備考,作者（敬称略）,アバターURL';

      // 差分組み立て（旧順序を尊重）。毎回 fresh なマップを使う
      const newMap = new Map(newMapOriginal);
      const changed: string[] = [];
      const keptOrderLines: string[] = [];
      for (const r of baseParsed.rows) {
        const id = r.id;
        if (newMap.has(id)) {
          const next = newMap.get(id)!;
          if (arraysEqual(next.fields, r.fields)) {
            keptOrderLines.push(r.raw);
          } else {
            changed.push(id);
            keptOrderLines.push(next.raw);
          }
          newMap.delete(id);
        } else {
          // 削除
          changed.push(id);
          // 何もpushしない（落とす）
        }
      }
      // 追加（旧に無いID）は新CSV順のまま末尾へ
      const addedIds = Array.from(newMap.keys());
      const addedLines = addedIds
        .map(id => newMap.get(id))
        .filter((entry): entry is { raw: string; fields: string[] } => !!entry)
        .map(entry => entry.raw);
      const allLines = [header, ...keptOrderLines, ...addedLines].filter(Boolean) as string[];
      const newBody = allLines.join(eol) + eol;
      const base64Content = btoa(unescape(encodeURIComponent(newBody)));

      const sha = currentSha;
      const putRes = await githubFetch(`/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`, token, {
        method: "PUT",
        body: JSON.stringify({
          message: `chore: update akyo-data.csv (via API)\nchanged: ${changed.join(', ')}\nadded: ${addedIds.join(', ')}` ,
          content: base64Content,
          branch,
          // 既存が無ければ sha 省略で新規作成
          ...(sha ? { sha } : {}),
        }),
      });

      if (putRes.ok) {
        let payload: any = null;
        try { payload = await putRes.json(); } catch (_) {}
        const commitSha = payload?.commit?.sha as string | undefined;
        const contentSha = payload?.content?.sha as string | undefined;
        const fileHtmlUrl = payload?.content?.html_url as string | undefined;
        const commitUrl = commitSha ? `https://github.com/${owner}/${repo}/commit/${commitSha}` : undefined;

        // アバターマップ自動更新（avatarURLに変更があった場合のみ）
        let avatarMapUpdated = false;
        try {
          avatarMapUpdated = await updateAvatarMapIfNeeded(newBody, currentBaseText, owner, repo, branch, token);
        } catch (e: any) {
          console.warn('Avatar map update failed:', e?.message);
        }

        return okJSON({
          ok: true,
          committed: true,
          attempt,
          owner,
          repo,
          branch,
          path,
          commitSha,
          contentSha,
          commitUrl,
          fileHtmlUrl,
          avatarMapUpdated,
        }, { headers: corsHeaders(origin) });
      }

      const status = putRes.status;
      lastErrorText = await putRes.text();
      // 409/422 は競合・検証エラー。短い指数バックオフで再試行
      if (status === 409 || status === 422) {
        await new Promise((r) => setTimeout(r, 300 * attempt));
        continue;
      }

      // その他は即エラー
      return errJSON(500, `github update failed: ${status} ${lastErrorText}`);
    }

    return errJSON(500, `github update failed after retries: ${lastErrorText || "conflict"}`);
  } catch (e: any) {
    if (e instanceof Response) return e;
    return errJSON(500, e?.message || "commit-csv failed");
  }
};


